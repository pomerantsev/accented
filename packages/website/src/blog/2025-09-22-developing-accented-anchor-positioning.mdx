---
title: "Developing Accented: anchor positioning"
description: TODO
author: Pavel Pomerantsev
---
import { Image } from 'astro:assets';
import exampleImg from '~/assets/images/blog-anchor-positioning-example.png';

In this post, I'll talk about:
- the positioning challenges of Accented.
- how anchor positioning solves those challenges.
- what's the fallback for non-supporting browsers.
  - tell more about Safari, how it works, but not really.

## The positioning challenge

For every element with accessibility issues, Accented inserts a button into the DOM,
which the user can click to open a dialog with issue details.

<Image
  src={exampleImg}
  alt="TODO"
  layout="constrained"
/>

The question is, how do we position that trigger button?

Remember, Accented can’t make any assumptions about the element with issues:

- It can be large or small.
- It can be anywhere in the DOM hierarchy.
- It can be any type of element: `<p>`, `<button>`, `<input>`, `<dialog>`, `<svg>`, you name it.
- It can have a position of `static`, `relative`, `absolute`, `fixed`, or `sticky`.
- It can happen to be inside a scrollable container.

In all of those scenarios,
the user should be able to find the trigger button easily and interact with it.

## DOM structure

The first part of the challenge is where to put the button in the DOM.

- Should it live inside the element with issues?
- Should it be a sibling of the element with issues?
- Should all the trigger buttons live inside a dedicated container?

TODO: consider showing code examples for each option.

The main issue with option 1 (inside the element) is that some elements can’t have children at all, for example, `<img>` or `<input>`.
Also, adding the button would invalidate some types of issues —
for example, the “empty button” issue would no longer be an issue if we inserted an Accented’s trigger button into it.

I ruled out option 3 (a dedicated container) primarily because of the focus order problem:
the trigger buttons would all come before or after the rest of the content in focus order,
and that seemed to be a non-ideal UX.
And there’s [a problem with modal dialogs](https://github.com/whatwg/html/issues/9936) too:
with such a setup, trigger buttons on elements inside a modal dialog simply wouldn’t work.

This leaves us with option 2: each trigger button sits next to the element that it’s associated with.

Now we’re getting to the actual positioning part.
How do we ensure that the trigger button is always at the top right (for left-to-right languages) of the element it is associated with?

## Absolute and fixed positioning

Before anchor positioning was available, we had two options for the trigger button: absolute and fixed positioning.

Each of these two options has its pros and cons.

### Absolute

We can calculate the position of the element with issues relative to its [offset parent](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent),
and use that to position the trigger button absolutely.

Something like this:

```js
triggerButton.style.position = 'absolute';

const left = elementWithIssues.offsetLeft;
triggerButton.style.left = `${left}px`;

/* Do the same for the other dimension,
   and adjust for size differences.
*/
```

Unfortunately, this approach breaks down in some scenarios:

- It doesn’t work if the element with issues has `position: sticky`.
  There’s no way to determine when the element gets “stuck” and update the position of the trigger button accordingly.

[//]: # (TODO: Dealing with videos in such a way is likely non-ideal. Consider this: https://docs.astro.build/en/guides/media/#can-i-use-astro-without-a-hosted-media-system)

<video src="/videos/sticky.mov" controls></video>

The only option is to listen to scroll events, but if we do that, we might as well use fixed positioning.

- If the element is in a scrollable region, and the offset parent is outside that region,
  the trigger button will stay in place when the user scrolls.

<video src="/videos/scrollable-region.mov" controls></video>

This could be mitigated, for example, by setting `position: relative` on the scrollable container,
but generally we’d like to avoid modifying the styles of the page as much as possible.

Which leaves us with fixed positioning.

### Fixed

When we use fixed positioning for trigger buttons, they are _usually_ positioned relative to the viewport.

The main implication is we have to listen to scroll events (emitted by any of the scroll containers)
and update the position of the trigger button accordingly.

This adds some scroll jank, but it’s likely not that big of a deal for a development tool.

<video src="/videos/scroll-jank.mov" controls></video>

Importantly, we listen to scroll events, which solves the challenges that we listed for absolute positioning.

The calculations get easier with fixed positioning though: a simple `getBoundingClientRect()` gives us the necessary offsets and sizes.

Unfortunately, in some cases, elements with fixed positioning are _not_ positioned relative to the viewport
(see [Identifying the containing block](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_display/Containing_block#identifying_the_containing_block)),
but that can be mitigated with [a few lines of code](https://github.com/pomerantsev/accented/blob/75cd006aa69bb45b91f4c71acdb6fa3485061ba4/packages/accented/src/utils/get-element-position.ts).

All in all, of the two options (absolute and fixed positioning), the latter seems to be a bit easier to work with.

## How anchor positioning helps

Anchor positioning is a new way to tie a position of one element to the position of another element.
See [Introducing the CSS anchor positioning API](https://developer.chrome.com/blog/anchor-positioning-api) for a primer.

And it’s a big deal for Accented, because it allows us to get rid of a bunch of JavaScript, and replace it with just a few lines of CSS.

We set the following on the element with issues:

```css
anchor-name: --accented-anchor-N;
```

And then on the trigger button, we set:

```css
position-anchor: --accented-anchor-N;
```

These are the properties that tie the two elements together.

Then comes the actual positioning, and it looks similar to the following:

```css
accented-trigger {
  position: fixed;
  right: anchor(right);
  top: anchor(top);
}
```

Forget about calculating sizes and offsets, and listening to scroll events.
Despite `position: fixed` (which we’ll talk about in the next section),
the trigger button will always be positioned relative to the element with issues,
and scroll with it.

TODO: research how the behavior of an element with anchor positioning should be different _according to the spec_ if it has `position: fixed` or `position: absolute`.

Now with anchor positioning, we can, as the name suggests, anchor the trigger to the element with issues.
TODO: talk in detail about anchor positioning.
Which means that we're free to place the element in the dom wherever we want (including as a sibling of the element with issues),
and the trigger will still be positioned correctly.
- It requires much less code.

## Caveats
- We need to update the value of `anchor-name` on the element with issues.
  We try to be careful and not break any existing styles (for example, we do XYZ),
  but it's hardly possible to be 100% safe.
- talk about transforms
- fixed vs absolute positioning

## Browser support
- Anchor positioning is still not supported in all browsers that Accented supports.
  - It's completely unsupported in Firefox.
  - In Safari, support was added very recently (version 26.0), but the implementation has a bug which prevents all the tests in Accented from passing.
  - In non-supporting browsers, we fall back to fixed positioning with scroll event listener.

## Bonus: logical properties
While not directly related to anchor positioning,
we use logical [CSS logical properties and values](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_logical_properties_and_values)
throughout the codebase.
This has a particular benefit: it's RTL support (TODO: add screenshots).

## Closing thoughts.
Anchor positioning is cool, and it's very helpful in some scenarios, but we still can't use it without providing a fallback.
