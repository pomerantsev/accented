---
title: "Developing Accented: anchor positioning"
description: TODO
author: Pavel Pomerantsev
---
import { Image } from 'astro:assets';
import exampleImg from '~/assets/images/blog-anchor-positioning-example.png';
import logicalPropertiesImg from '~/assets/images/blog-anchor-positioning-logical-properties.png';

In this post, I'll talk about:
- the element positioning challenges in Accented;
- how [CSS anchor positioning](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_anchor_positioning) solves those challenges;
- the state of anchor positioning today.

## The positioning challenge

For every element with accessibility issues, Accented inserts a button into the DOM,
which the user can click to open a dialog with issue details.

<Image
  src={exampleImg}
  alt="TODO"
  layout="constrained"
/>

The question is, how do we position that trigger button?

Remember, Accented can’t make any assumptions about the element with issues:

- It can be large or small.
- It can be anywhere in the DOM hierarchy.
- It can be any type of element: `<p>`, `<button>`, `<input>`, `<dialog>`, `<svg>`, you name it.
- It can have a position of `static`, `relative`, `absolute`, `fixed`, or `sticky`.
- It can happen to be inside a scrollable container.

In all of those scenarios,
the user should be able to find the trigger button easily and interact with it.

## DOM structure

The first part of the challenge is where to put the button in the DOM.

- Should it live inside the element with issues?
- Should it be a sibling of the element with issues?
- Should all the trigger buttons live inside a dedicated container?

TODO: consider showing code examples for each option.

The main issue with option 1 (inside the element) is that some elements can’t have children at all, for example, `<img>` or `<input>`.
Also, adding the button would invalidate some types of issues —
for example, the “empty button” issue would no longer be an issue if we inserted an Accented’s trigger button into it.

I ruled out option 3 (a dedicated container) primarily because of the focus order problem:
the trigger buttons would all come before or after the rest of the content in focus order,
and that seemed to be a non-ideal UX.
And there’s [a problem with modal dialogs](https://github.com/whatwg/html/issues/9936) too:
with such a setup, trigger buttons on elements inside a modal dialog simply wouldn’t work.

This leaves us with option 2: each trigger button sits next to the element that it’s associated with.

Now we’re getting to the actual positioning part.
How do we ensure that the trigger button is always at the top right (for left-to-right languages) of the element it is associated with?

## Absolute and fixed positioning

Before anchor positioning was available, we had two options for the trigger button: absolute and fixed positioning.

Each of these two options has its pros and cons.

### Absolute

We can calculate the position of the element with issues relative to its [offset parent](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent),
and use that to position the trigger button absolutely.

Something like this:

```js
triggerButton.style.position = 'absolute';

const left = elementWithIssues.offsetLeft;
triggerButton.style.left = `${left}px`;

/* Do the same for the other dimension,
   and adjust for size differences.
*/
```

Unfortunately, this approach breaks down in some scenarios:

- It doesn’t work if the element with issues has `position: sticky`.
  There’s no way to determine when the element gets “stuck” and update the position of the trigger button accordingly.

[//]: # (TODO: Dealing with videos in such a way is likely non-ideal. Consider this: https://docs.astro.build/en/guides/media/#can-i-use-astro-without-a-hosted-media-system)

<video src="/videos/sticky.mov" controls></video>

The only option is to listen to scroll events, but if we do that, we might as well use fixed positioning.

- If the element is in a scrollable region, and the offset parent is outside that region,
  the trigger button will stay in place when the user scrolls.

<video src="/videos/scrollable-region.mov" controls></video>

This could be mitigated, for example, by setting `position: relative` on the scrollable container,
but generally we’d like to avoid modifying the styles of the page as much as possible.

Which leaves us with fixed positioning.

### Fixed

When we use fixed positioning for trigger buttons, they are _usually_ positioned relative to the viewport.

The main implication is we have to listen to scroll events (emitted by any of the scroll containers)
and update the position of the trigger button accordingly.

This adds some scroll jank, but it’s likely not that big of a deal for a development tool.

<video src="/videos/scroll-jank.mov" controls></video>

Importantly, we listen to scroll events, which solves the challenges that we listed for absolute positioning.

The calculations get easier with fixed positioning though: a simple `getBoundingClientRect()` gives us the necessary offsets and sizes.

Unfortunately, in some cases, elements with fixed positioning are _not_ positioned relative to the viewport
(see [Identifying the containing block](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_display/Containing_block#identifying_the_containing_block)),
but that can be mitigated with [a few lines of code](https://github.com/pomerantsev/accented/blob/75cd006aa69bb45b91f4c71acdb6fa3485061ba4/packages/accented/src/utils/get-element-position.ts).

All in all, of the two options (absolute and fixed positioning), the latter seems to be a bit easier to work with.

## How anchor positioning helps

Anchor positioning is a new way to tie a position of one element to the position of another element.
See [Introducing the CSS anchor positioning API](https://developer.chrome.com/blog/anchor-positioning-api) for a primer.

And it’s a big deal for Accented, because it allows us to get rid of a bunch of JavaScript, and replace it with just a few lines of CSS.

We set the following on the element with issues:

```css
anchor-name: --accented-anchor-N;
```

And then on the trigger button, we set:

```css
position-anchor: --accented-anchor-N;
```

These are the properties that tie the two elements together.

Then comes the actual positioning, and it looks similar to the following:

```css
accented-trigger {
  position: fixed;
  right: anchor(right);
  top: anchor(top);
}
```

Forget about calculating sizes and offsets, and listening to scroll and resize events
(which amounts to approximately 400 lines of JavaScript code).

Despite `position: fixed` (which we’ll talk about in the next section),
the trigger button will always be positioned relative to the element with issues,
and scroll along with it.

[TODO: add a video showing how it works.]

Another good thing about anchor positioning is that it works with any [DOM structure](#dom-structure).
Of course, the DOM placement of the trigger buttons still affects semantics, UX, and accessibility,
but with anchor positioning, it doesn’t affect the visual appearance.

## Caveats

Anchor positioning comes with its own set of challenges.

- **It’s not supported in all browsers.**
  Firefox hasn’t implemented anchor positioning yet,
  and [in the latest Safari (26) the implementation is buggy](https://github.com/Fyrd/caniuse/pull/7387).
  Because of that, we still need to maintain a fallback that uses fixed positioning and a scroll event listener.
- **`anchor-name` needs to be set on the element with issues.**
  It’s yet another DOM change in the host app, which is unfortunately impossible to avoid.
- **The [anchor positioning spec](https://www.w3.org/TR/css-anchor-position-1) has some rough edges.**
  For example, CSS transforms are not taken into account when calculating the position of the anchored element,
  so if the element with issues has a transform applied to it,
  we need to apply the same transform to the trigger button.
- **There’s a subtle difference between `position: fixed` and `position: absolute` when using anchor positioning.**
  When set on the trigger button, `position: fixed` and `position: absolute` work mostly the same,
  except when the anchor (the element with issues) is itself fixed-positioned.
  In that case, TODO: I'm too exhausted to come up with the right wording.

## Bonus: logical properties

[Logical properties and values](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_logical_properties_and_values)
are a great addition to CSS, but they are unfortunately not used as widely as they should be.

They allow us to write CSS that works for both left-to-right and right-to-left languages.
Which is what Accented needs — it’s meant to work for all web apps, regardless of the language.

```css
/* A physical property, which works as intended for English
   (a margin at the start of the line),
   but if we get content in Hebrew or Arabic,
   the margin is suddenly at the end of the line,
   which is not what we intended. */
margin-left: 2rem;

/* A logical property, which sets the margin
   _at the start of the line_, which is on the left
   for a left-to-right language (English),
   and on the right for a right-to-left one (Hebrew). */
margin-inline-start: 2rem;
```

If we apply this to our earlier positioning code (see [How anchor positioning helps](#how-anchor-positioning-helps)),
we get the following:

```css
accented-trigger {
  position: fixed;
  inset-inline-end: anchor(end);
  inset-block-start: anchor(start);
}
```

It’s true that this code becomes slightly less intuitive (especially if you’re not used to logical properties),
but now we don’t need to write anything extra for right-to-left languages —
the trigger buttons will appear at the top right or the top left, depending on the language direction.

<Image
  src={logicalPropertiesImg}
  alt="TODO"
  layout="constrained"
/>

## Closing thoughts.

Positioning in CSS surely is complicated, especially if we know nothing about the content
(which is true for Accented).

Anchor positioning makes styling so much easier in Accented, especially when paired with CSS logical properties.

The spec is still evolving, and we can’t use anchor positioning without fallbacks if we want Accented to work in all major browsers,
but it already works for the majority of users, and in a year or two,
we will hopefully be able to drop the fallback code altogether.

And deleting 400 lines of code is surely something to look forward to.
